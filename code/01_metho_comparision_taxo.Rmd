---
title: "01_metho_comparision_taxo"
author: "Mathis Gheno"
date: "2024-09-20"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

***

## load required packages

```{r packages, message=FALSE}
library(tidyverse)
library(ade4) # Coinertia
library(vegan) # Rarefaction
library(ggrepel)
library(metacoder)

main_theme = theme_minimal()+
  theme(line = element_blank(), 
        axis.line = element_line(colour = "black"),
        panel.border = element_blank(),
        axis.ticks =  element_line(colour = "black"),
        axis.text.x = element_text(colour = "black", size=22, face="italic", angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(colour = "black", size=22, face="italic"),
        legend.title = element_text(colour = "black", size=20,
                                    hjust =0.5),
        
        legend.text = element_text(colour = "black", size=18),
        axis.title= element_text(size=28),
        strip.text = element_text(colour = "black", size=15, face ="italic"))
```

## Data path
```{r}
metab1 = "data/metabarcoding_vs_metagenomics/oracle_metaBt0_16S_samples_run_20190715_kraken2_assignment_genuses.tsv"
metab2 = "data/metabarcoding_vs_metagenomics/oracle_metaBt0_16S_samples_run_20200106_kraken2_assignment_genuses.tsv"
metag1 = "data/metabarcoding_vs_metagenomics/oracle_metaGt0_SAMA_12_samples_kraken2_SSU_assignment_genuses.tsv"
metag2 = "data/metabarcoding_vs_metagenomics/oracle_metaGt0_SAMA_21_1_samples_kraken2_SSU_assignment_genuses.tsv"
metag3 = "data/metabarcoding_vs_metagenomics/oracle_metaGt0_SAMA_21_2_samples_kraken2_SSU_assignment_genuses.tsv"
```

# Load data

## Set up function to load and pepare data 
```{r}
taxonomic_levels <- c("kingdom", "phylum", "class", "order", "family", 
                      "genus", "species")
## ---- Arrange metaB ----

# Select data from bracken method, and rename columns 
select.and.rename.cols = function(tab, method = "G"){
  tab %>%
    read_tsv(col_names = T, skip = 1) %>%
    select(contains("bracken_genuses"), `#OTU ID`, taxonomy) %>%
    rename_with( # rename colnames
      . %>%
      str_remove( "_bracken_genuses") %>% 
      str_replace_all("^OR-", "BU_") %>% 
      str_replace_all("-", "_") %>%
      str_remove("_S\\d+") %>%
      #  (^T_) Select strings with the letter T at the begening of the string; (\\d) detect number ; 
      #  "CONT_BU_PCR_\\2" replace name to matching string and add group 2 (which corespond to  (\\d) )
      str_replace("(^T_)(\\d)", "CONT_BU_PCR_\\2") %>% 
      str_replace("(BU_T_extr)", "CONT_BU_ext") %>%
      str_replace("(^T_Ex)", "CONT_BU_ext") %>%
      str_replace("#OTU ID", "OTU") %>%
      # add a 0 in matich sting ex : BU_SER_1_R1 -> BU_SER_01_R1
      str_replace("(BU_[A-Z]+_)(\\d{1})(_R\\d+)", "\\10\\2\\3")
      ) %>% # add 0 before 1-Digit Numbers of soil code
    rename_with(~ paste0(., "_", method), contains("BU")) %>% # add B or G at the end of soil code depending on the method 
      
    separate_wider_delim(taxonomy, names = taxonomic_levels, delim = "; ", cols_remove = F) # Separate taxonomy colums in 6 colums of taxonomic levels
    # filter(kingdom == "k__Bacteria")
}

```

## Decontamination function

Compute the total number of reads for each OTU present in control
samples. That sum is then substracted from all occurrences of that OTU
in true samples. The rationale is as follows:

- if an OTU is abundant in control samples, but rare in true samples,
  then it is a contamination specific to the control samples, and it
  will be eliminated by the substraction (i.e, final abundance is 0),
- if an OTU is present in control samples, and present in true samples
  (systematic contamination, will be mitigated by the substraction),
 - if an OTU is rare in control samples, but abundant in true samples
  (cross-talk, will be eliminated/mitigated by the substraction)

Control samples can be eliminated from the statistical analysis after
the substraction (all OTUs present in control samples have been zeroed
out).
```{r}
. %>%
  #select(!ends_with(run_rm))%>%
  replace(. == 0, NA) %>%
  pivot_longer(starts_with("BU"), names_to = "samples", values_to = "reads") %>%
  filter(!is.na(reads)) %>%
  #{{merge control samples}}
  mutate( n = rowSums(across(starts_with("CONT")), na.rm = T))%>%
  #{{substract abundance of control samples}}
  mutate(reads = case_when(
    is.na(n)  ~ reads,
    n > reads ~ 0,
    TRUE      ~ reads - n)) %>%
  select(-n,-starts_with("CONT"))%>%
  pivot_wider(values_from = reads, names_from = samples, values_fill = 0) -> decontaminate


```



## Load and format data for coinertia

```{r}
metab1 %>%
 select.and.rename.cols("B") %>%
 decontaminate -> metab1_decont_table

metab2 %>%
 select.and.rename.cols("B") %>%
 decontaminate -> metab2_decont_table
metab2_decont_table%>% colnames
# Merge run 1 and 2 of metaB, because some sample failed in the first run
metab1_decont_table%>%
  full_join(metab2_decont_table, by = join_by(OTU == OTU, kingdom == kingdom, phylum == phylum,
                                               class == class, order == order, family == family,
                                               genus == genus,  species == species, taxonomy == taxonomy)) %>%
  select(-ends_with(".x")) %>% # Remove conflicting columns from the left-hand side
  rename_with(~ sub(".y", "", .), ends_with(".y")) %>%  # Rename right-hand columns
  mutate(across(where(is.numeric), ~ replace(., is.na(.), 0))) -> metab_decont_table

          
metag1 %>%
 select.and.rename.cols("G") %>%
 decontaminate-> metag1_decont_table

metag3 %>%
 select.and.rename.cols("B") %>%
 decontaminate%>% colnames

metag1_decont_table %>%
  full_join(metab_decont_table, by = join_by(OTU == OTU, kingdom == kingdom, phylum == phylum,
                                               class == class, order == order, family == family,
                                               genus == genus,  species == species, taxonomy == taxonomy)) %>%
   mutate(across(where(is.numeric), ~ replace(., is.na(.), 0)))%>%
   select(-c(BU_TS_15_R1_B, BU_TS_15_R2_B)) -> meta_g_b_decond_table # remove sample because missing for metaG
meta_g_b_decond_table %>%colnames
```

```{r}
metab1_decont_table %>%
  select(starts_with("BU")) %>% rowSums
```
Is it normal that some OTU have 0 reads ?


### Rarefaction function 
```{r}
rarefaction.func = function(df,rar_sample, rarcur = T){
  
  
  if(rarcur){ # {{ if rarefaction curve needed}}
    metab1_decont_table%>%
  select(starts_with("BU"))%>%
  t()%>%rarecurve(step = 20, sample = rar_sample, col = "blue", cex = 0.6)
  }
   # {{rarefaction}}
  df%>%
    select(starts_with("BU"))%>%
    t()%>%
    rrarefy(rar_sample)%>%
    t()%>%
    bind_cols(
      df%>%select(!starts_with("BU"))
    )-> df_rarefy
  return(df_rarefy)
}

```

### Variance per OTU per method across samples

```{r}
meta_g_b_decond_table %>% 
  filter(rowSums(across(starts_with("BU")), na.rm = T) != 0) %>%
  pivot_longer(starts_with("BU"), names_to = "sample_ID", values_to = "reads") %>%
  mutate(method = str_extract(sample_ID, "R\\d_[A-Z+]")) %>%
  group_by(OTU, method) %>%
  summarise(reads_var = log10(var(reads, na.rm = T)+1)) %>%
  ungroup() %>%
  ggplot()+
  facet_wrap(~method)+
  geom_histogram(aes(x = reads_var))
```

Meta genomic miss more OTU that meta barcoding. Exept for 0, variance distribution of OTU number of reads look like similar for both method. It suggest that both method give an over all similar distribution of OTUs between samples, but without OTUs ID I cannot be sure for individual OTUs or groups of OTUs (taxa).

### Variance per OTU
```{r}
meta_g_b_decond_table %>%
  filter(rowSums(across(starts_with("BU")), na.rm = T) !=0 )%>%
  pivot_longer(starts_with("BU"), names_to = "sample_ID", values_to = "reads") %>%
  mutate(soil_code = str_extract(sample_ID, "(BU_[A-Z]+_)(\\d+)")) %>%
  group_by(OTU,soil_code) %>%
  summarise(reads_var = log10(var(reads, na.rm = T))) %>%
  ungroup() %>%
  ggplot()+
  geom_histogram(aes(x = reads_var))
```
Not much 
### Which value to rarefy ?
```{r}
meta_g_b_decond_table %>%
  pivot_longer(starts_with("BU"), names_to = "sample_ID", values_to = "reads") %>%
  group_by(sample_ID) %>%
  summarise(reads_sum = sum(reads)) %>% 
  arrange(reads_sum) ->size_eff

size_eff$reads_sum[1] -> min_ech

size_eff %>%
  mutate(method = str_extract(sample_ID, "R\\d_[A-Z+]")) %>%
  ggplot()+
  geom_point(aes(x = reorder(sample_ID, reads_sum), y = reads_sum, col = method))+
  scale_y_log10()
```


### Rarefaction
```{r}
meta_g_b_decond_table%>%rarefaction.func(rar_sample = min_ech, rarcur = T) -> meta_g_b_decond_table_rare

```

## Co-inertia

### Fist PCA for each method
```{r}
pca.for.method <- function(tab, method){
  tab %>%
  column_to_rownames("OTU")%>%
  select(ends_with(method))%>%
  select(order(colnames(.)))%>%
  decostand(method = "hellinger")%>%
  ade4::dudi.pca( scale = TRUE, scan = FALSE, nf = 3) -> pca_obj

  return(pca_obj)
}
```

### Better graphical representation function
```{r}
### ---- better graph representation for coinertia
coin.graph = function(coin_obj,meta_obj, brin, method){
  # {{recover coordinate in the ordination space of the 2 method to compaire}}
  cbind(coin_obj$mX,coin_obj$mY) ->  df_coin_pos
  colnames(df_coin_pos) = c("metho1_x", "metho1_y", "metho2_x", "metho2_y")
  
  
  df_coin_pos%>%
    rownames_to_column("OTU")%>%
    mutate(OTU = as.numeric(OTU))%>%
     # {{recover OTU and genus information}}
    left_join(meta_obj%>%
                select(OTU, genus), by = "OTU")%>%
    # {{Find taxa with the higher and lower diff (lower and higer distance in the ordination space between metho1(x,y) and metho2(x,y) )}}
    mutate(dist =  sqrt(rowSums((coin_obj$mX-coin_obj$mY)^2)))%>%
    arrange(desc(dist)) %>%
    slice(c(1:10, (n() - 9):n()))%>%
    # {{add a colums to facet_wrap}}
    mutate(diff = c(rep("Strong",10 ), rep("Weak", 10)))%>%
    ggplot()+
    facet_wrap(~diff)+
    geom_label_repel(aes(x= metho1_x, y = metho1_y ,label = genus))+
    geom_segment(aes(x = metho1_x, y = metho1_y, xend = metho2_x, yend = metho2_y),
                 arrow = arrow(length = unit(0.3, "cm"), type = "closed"), cex =1)+
    
    labs(x="X",y = "Y", title = paste("Genera estimations differences between", brin[1],method[1], "(arrow tail) and", brin[2],method[2], "(arrow head) across 80 samples"))+
    main_theme
    }
```

### Idea of coinertia

Usually coinertion is done with matrix (OTU(row) x sample(col)) because we are looking for community difference across site. Here I am interested by site difference across across sample, in orther words we want to know if distribution per species/taxa  is similare across samples. To do so I use the matrix : samples(row) x OTU(col) (transpose of the previous one)

Let's take a look at the difference with a small example:

I create 2 simplified data frame (obtaine with method A and B) with the 3 same species and 3 same samples. 
```{r}
A <- data.frame(sample1A = c(0.4,0,0.6), sample2A = c(0,1,0), sample3A = c(0.33,0.33,0.33), sp = c("sp1", "sp2" ,"sp3")) %>%
  column_to_rownames("sp") %>%
  t()
B <- data.frame(sample1B = c(0,0.4,0.6), sample2B = c(1,0,0), sample3B = c(0.33,0.33,0.33), sp = c("sp1", "sp2" ,"sp3")) %>%
  column_to_rownames("sp") %>%
  t()
A %>%
  knitr::kable()
B%>%
  knitr::kable()

```

```{r}
# test metric
  
# A%>%t() != 0 ->  A_T
# B%>%t() != 0 ->  B_T
# 
# a = rowSums(A_T & B_T)
# b = rowSums(xor(A_T, B_T) & A_T)
# c = rowSums(xor(A_T, B_T) & B_T)
# d = rowSums(!(A_T | B_T))
# n = a + b + c + d
# E = (a + b)*(a + c)/n # (expected occurrences in A)*(expected occurrences in B)/(total occurances) = expected co-occurrences
# E>= a
# 
# 1-pchisq((n*abs(a*d-b*c) - n/2)^2/((a + b)*(c + d)*(a + c)*(b + d)), 1)
# (n*abs(a*d-b*c) - n/2)^2/((a + b)*(c + d)*(a + c)*(b + d))
# 
# (2*rowSums(A_T|B_T))/(2*rowSums(A_T & B_T) + 2*rowSums(A_T | B_T) )
# sqrt(rowSums((A%>%t() - B%>%t())^2))
# 

# meta_g_b_decond_table%>%
#   select(ends_with("R1_G")) -> meta_g_R1
# meta_g_b_decond_table%>%
#   select(ends_with("R1_B")) -> meta_b_R1
# meta_g_R1-meta_b_R1
# meta_b_R1 != 0 -> meta_g_R1_bin
# meta_b_R1 != 0 -> meta_b_R1_bin
# 
# a = rowSums(meta_b_R1_bin & meta_g_R1_bin)
# b = rowSums(xor(meta_b_R1_bin,meta_g_R1_bin)&meta_b_R1_bin)
# c = rowSums(xor(meta_b_R1_bin,meta_g_R1_bin)&meta_g_R1_bin)
# d = rowSums(!(meta_b_R1_bin| meta_g_R1_bin))
# n = a + b + c + d
# E = (a + b)*(a + c)/n # (expected occurrences in A)*(expected occurrences in B)/(total occurances) = expected co-occurrences
# E>= a
# par(mfrow = c(1,1))
# X2_value = n*(abs(a*d-b*c) - n/2)^2/((a + b)*(c + d)*(a + c)*(b + d))
# p_value <- 1 - pchisq(X2_value, 1)
# plot(sqrt(rowSums(((meta_b_R1/rowSums(meta_b_R1) - meta_g_R1/rowSums(meta_g_R1)))^2)),p_value )

```

sp1 and sp2 have a different distribution across sample between A and B. sp3 have identical distribution between A and B

If we look at first approach (community difference across site)

```{r}
library(factoextra)
library(FactoMineR)
A %>%
  dudi.pca( scale = TRUE, scan = FALSE, nf = 3) -> pca_A
factoextra::fviz_pca_biplot(pca_A, repel = TRUE, col.var = "#2E9FDF", col.ind = "#696969")

B  %>%
  dudi.pca( scale = TRUE, scan = FALSE, nf = 3) -> pca_B
factoextra::fviz_pca_biplot(pca_B, repel = TRUE, col.var = "#2E9FDF", col.ind = "#696969")
```
PCA show us which sample is associated to which species. Here species are considered as variables defining samples

Co-inertia will show us the difference between sample.
Here we could suppose that we will detect differences between sample 1; 2 A and 1; 2 B  and no differences between 3 A and 3 B...
```{r}
coin_test <- ade4::coinertia(pca_A,pca_B, scan = FALSE, nf = 2)
pca_A$co
pca_B$co
summary(coin_test)
plot(coin_test)
```

But surprisingly there is no sample differences detected between methods. (sampleN A and B overlap on the plot)
The reason is that co-inertia project correlated variables in same "area" on the ordination space.
Here our variables are *sp1*, *sp2* and *sp3*. 
*sp1* and *sp2* are mirror of each other and *sp3* is identical between methods thus
**(1)** *sp1 A* go with *sp2 B*,  **(2)** *sp2 1* go with *sp1 B* and **(3)** *sp3 A* and *B* are in the same position. Following this logic:
  - Sample 1 contain either *sp1 + sp3* (for A) or *sp2 + sp3* (for B). *sp3* isn't discriminant between A and B so Sample1 A and B are in the same position in the ordination space because of **(1)*
  - Sample 2 contain either *sp2* (for A) or *sp1* (for B).So Sample2 A and B are in the same position in the ordination space because of **(2)**
  - Sample 3 are identical between A and B, not surprising that they are ath the same position
  
Now the second option
```{r}
A %>% 
  t() %>%
  knitr::kable()
B%>% 
  t() %>%
  knitr::kable()
```




```{r}
as.data.frame(t(A)/rowSums(t(A))) %>%
  #t() %>%
  ade4::dudi.coa( nf = 3, scannf = FALSE) -> pca_A_t
factoextra::fviz_pca_biplot(pca_A, repel = TRUE, col.var = "#2E9FDF", col.ind = "#696969")

as.data.frame(t(B)/rowSums(t(B))) %>%
  #t() %>%
  ade4::dudi.coa(nf = 3,scannf = FALSE) -> pca_B_t
factoextra::fviz_pca_biplot(pca_B, repel = TRUE, col.var = "#2E9FDF", col.ind = "#696969")
```

Here samples are considered as variables defining species. We can already see that sample 3 account for no variation between species, which is normal because sp1 2 and 3 are represented equally in sample 3 (regardless of the method A or B).

Now lets compute the coinertia. The coineratia in this case with maximise covariance between samples A axis and sample B axis

Here we could suppose that we will detect differences between all species 1 A and B, or species 2 A and B but no differences between species 3 A and B
```{r}
coin_test <- ade4::coinertia(pca_A_t, pca_B_t, scan = FALSE, nf = 3)

summary(coin_test)
plot(coin_test)
```

Zut !

### Create PCA for 4 methods

```{r}
pca.for.method(tab = meta_g_b_decond_table, method = "R1_B") -> dudi_b_r1

pca.for.method(meta_g_b_decond_table, "R2_B") -> dudi_b_r2

pca.for.method(meta_g_b_decond_table, "R1_G") -> dudi_g_r1

pca.for.method(meta_g_b_decond_table, "R2_G") -> dudi_g_r2

# Just check if sample are well order (it should not impact the analysis but I do in case it would.
# And it always better to know it is arrange the same way between the 4 method)
dudi_b_r1$tab%>%
    colnames%>%
    str_extract("BU_[A-Z]+_\\d+") == dudi_b_r2$tab%>%
                                        colnames%>% 
                                        str_extract("BU_[A-Z]+_\\d+")
dudi_b_r1$tab%>%
    colnames%>%
    str_extract("BU_[A-Z]+_\\d+") == dudi_g_r2$tab%>%
                                        colnames%>%
                                        str_extract("BU_[A-Z]+_\\d+")
#no ts 15 in G
#no ser 10 in B
dudi_b_r1$tab%>%
    colnames%>%
    str_extract("BU_[A-Z]+_\\d+") == dudi_g_r1$tab%>%
                                        colnames %>%
                                        str_extract("BU_[A-Z]+_\\d+")
```

I'm doing the Hellinger transformation on the matrix (OTU x site). Usually the transformation (and the coinertia by extension) is done on the transpose of this matrix (site x species/OUT).It is because most of the time we are interested in the difference of species composition in sites. However here we are interested in the species detection difference, in other word we are looking for difference of species abundances in sites

/!\ Do separate or merge Hellinger transformation on the 2 df ?

### Metabarcoding R1 vs R2

```{r}
coin1 <- ade4::coinertia(dudi_b_r1, dudi_b_r2, scan = FALSE, nf = 2)

summary(coin1)
plot(coin1)
coin.graph(coin_obj = coin1, meta_obj= meta_g_b_decond_table, brin = c("R1","R2"), method = c("metaB", "metaB"))
```

### Metagenomic R1 vs R2

```{r}
coin2 <- ade4::coinertia(dudi_g_r1, dudi_g_r2, scan = FALSE, nf = 2)

summary(coin2)
plot(coin2)
coin.graph(coin2, meta_obj= meta_g_b_decond_table, brin = c("R1","R2"), method = c("metaG", "metaG"))
```

### Metabarcoding R1 vs Metagenomic R1
```{r}
coin3 <- ade4::coinertia(dudi_b_r1, dudi_g_r1, scan = FALSE, nf = 2)

summary(coin3)
plot(coin3)
coin.graph(coin3, meta_obj= meta_g_b_decond_table, brin = c("R1","R1"), method = c("metaB", "metaG"))
```

### Metabarcoding R2 vs Metagenomic R2
```{r}
coin4 <- ade4::coinertia(dudi_b_r2, dudi_g_r2, scan = FALSE, nf = 2)

summary(coin4)
plot(coin4)
coin.graph(coin_obj = coin4, meta_obj= meta_g_b_decond_table, brin = c("R2","R2"), method = c("metaB", "metaG"))
```


## Metacoder and phyloseq

```{r}
library(phyloseq)

phyloseq_to_edgeR = function(physeq, group, method="RLE", ...){
  require("edgeR")
  require("phyloseq")
  # Enforce orientation.
  if( !taxa_are_rows(physeq) ){ physeq <- t(physeq) }
  x = as(otu_table(physeq), "matrix")
  # Add one to protect against overflow, log(0) issues.
  x = x + 1
  # Check `group` argument
  if( identical(all.equal(length(group), 1), TRUE) & nsamples(physeq) > 1 ){
    # Assume that group was a sample variable name (must be categorical)
    group = get_variable(physeq, group)
  }
  # Define gene annotations (`genes`) as tax_table
  taxonomy = tax_table(physeq, errorIfNULL=FALSE)
  if( !is.null(taxonomy) ){
    taxonomy = data.frame(as(taxonomy, "matrix"))
  } 
  # Now turn into a DGEList
  y = DGEList(counts=x, group=group, genes=taxonomy, remove.zeros = TRUE, ...)
  # Calculate the normalization factors
  z = calcNormFactors(y, method=method)
  # Check for division by zero inside `calcNormFactors`
  if( !all(is.finite(z$samples$norm.factors)) ){
    stop("Something wrong with edgeR::calcNormFactors on this data,
         non-finite $norm.factors, consider changing `method` argument")
  }
  # Estimate dispersions
  return(estimateTagwiseDisp(estimateCommonDisp(z)))
}
```

### Function that compute differential analysis
 
return an object compatible with metacoder

```{r}
differential.analysis <- function(obj, pair){
  
  # Extract taxon rank associated to each Metacoder taxon_id
  rank_df = data.frame(taxon_rank = sapply(names(obj$taxa), function(x) obj$taxa[[x]]$rank$name)) %>%
  rownames_to_column("taxon_id")
  
  # Join taxon rank and taxon total abundances data frame
  rank_df %>%
    left_join(obj$data$tax_abund, by = "taxon_id", ) %>%
  tibble -> tax_abund
  
  # Create sample data (data frame that indicate sample's condition/method belonging)
  data.frame(sample_ID = colnames(tax_abund %>%
                                    select(starts_with("BU")))) %>%
      mutate(method = str_extract(sample_ID, "R\\d_[A-Z+]$")) %>%
      column_to_rownames("sample_ID") -> sampledata
  # Initialize output dataframe
  pair_wise_taxa_df = data.frame()
  for(t_rank in unique(tax_abund$taxon_rank)){
    
    # Compute OTU table with sample from both method in colums and taxa in rows
    tax_abund %>%
      filter(taxon_rank == t_rank) %>%
      select(starts_with("BU"), taxon_id) %>%
      column_to_rownames("taxon_id") -> otu_tab
    
    # Compute tax table taxon id as row name and also as a colums. Need to be formatred like this 
    # for phyloseq func. I just need to have colums that discriminates taxe, which taxon_id from 
    # metacoder do perfecly. It is why do not recover the full taxa description (Kindom, class, ...)
    tax_abund%>%
      filter(taxon_rank == t_rank) %>%
      select(taxon_id)%>%
      mutate(taxon_id2 = taxon_id)%>%
      column_to_rownames("taxon_id2")%>%
      as.matrix-> tax_tab
  
    physeq_obj = phyloseq(otu_table(otu_tab, taxa_are_rows = T), tax_table(tax_tab), sample_data(sampledata))
  
    ge = phyloseq_to_edgeR(physeq_obj, group="method")
    et = exactTest(ge, pair=c(pair[2], pair[1]))
    # Extract values from test results
    tt = topTags(et, n=nrow(dge$table), adjust.method="fdr", sort.by="PValue")
    res = tt@.Data[[1]]
    
    pair_wise_taxa_df %>%
      bind_rows(res %>%
                  select(taxon_id, logFC, logCPM, PValue, FDR))%>%
      tibble() -> pair_wise_taxa_df
  }
  return(pair_wise_taxa_df)
}
```

### Function that make the metacoder object that contain the taxonomic comparison tree

```{r}

make.tax.tree.comp = function(df, pair){
  df %>%
  select(OTU, kingdom, phylum, class, order, family, genus, species, taxonomy, ends_with(pair[1]), ends_with(pair[2]))%>%
  mutate(sum_col = rowSums(across(c(ends_with(pair[1]), ends_with(pair[2]))),na.rm = T))%>%
  filter(sum_col != 0)%>%
  ## standardization of the table produce by the "pair 1" (first pair put in the vector)
  # mutate(across(ends_with(pair[1]), ~ sqrt(. / rowSums(across(ends_with(pair[1])))), .names = "hellinger_{col}"), 
  ## standardization of the table produce by the "pair 2" (second pair put in the vector)    
  #across(ends_with(pair[2]), ~ sqrt(. / rowSums(across(ends_with(pair[2])))), .names = "hellinger_{col}"),.keep = "unused")%>%
  # remove species that don't appear in the 2 pair that we compare in this chunk}}
  mutate(total = rowSums(across(starts_with("BU")), na.rm = T))%>%
  filter(total !=0 )%>%
  # create metacoder object
  metacoder::parse_tax_data(class_cols = "taxonomy", # The column in the input table
                      class_sep = "; ",
                      class_regex = "^([a-z]{0,1})_{0,2}(.*)$",
                      class_key = c("tax_rank" = "taxon_rank", "name" = "taxon_name")) -> obj
  
  # compute abudance (standadize by hellinger) per taxon for the 2 paire
  obj$data$tax_abund <- metacoder::calc_taxon_abund(obj, "tax_data",
                                       cols = startsWith(colnames(obj$data$tax_data),"BU"))
  
  obj$data$tax_abund_group <- metacoder::calc_taxon_abund(obj, "tax_data",
                                       cols = startsWith(colnames(obj$data$tax_data),"BU"),
                                                         groups = str_extract(str_subset(colnames(obj$data$tax_data), "_R\\d_[A-Z+]"), "R\\d_[A-Z+]"))
  obj$data$diff_table = metacoder::compare_groups(obj, "tax_abund",
                                       cols = startsWith(colnames(obj$data$tax_abund),"BU"),
                                                         groups = str_extract(str_subset(colnames(obj$data$tax_abund), "_R\\d_[A-Z+]"), "R\\d_[A-Z+]"))
  obj = mutate_obs(obj, "diff_table",
                  wilcox_p_value = p.adjust(wilcox_p_value, method = "fdr"))
  # Ns. set to 0
  obj$data$diff_table%>%
    mutate(median_diff = case_when(wilcox_p_value > 0.05 ~ 0,
                      .default  = median_diff),
           log2_median_ratio = case_when(wilcox_p_value > 0.05 ~ 0,
                      .default  = median_diff)) -> obj$data$diff_table
  
  
  # differential analysis of sequence read count data with edgeR
  obj$data$diff_analysis_table = differential.analysis(obj = obj, pair = pair)
  
  # Ns. set to 0
  obj$data$diff_analysis_table%>%
    mutate(logFC = case_when(FDR > 0.05 ~ 0,
                      .default  = logFC),
           logCPM = case_when(FDR > 0.05 ~ 0,
                      .default  = logCPM)) -> obj$data$diff_analysis_table
  return(obj)
}

```


### Metabarcoding R1 vs R2 

```{r}
meta_g_b_decond_table%>%
  make.tax.tree.comp(pair = c("R1_B","R2_B")) -> obj1

obj1$data$diff_analysis_table
obj1%>%
  metacoder::filter_taxa(taxon_ranks == "o", supertaxa = TRUE)%>%
  metacoder::heat_tree(node_label = gsub(pattern = "\\[|\\]", replacement = "", taxon_names),
            node_size = R1_B+R2_B,
            node_color = R1_B-R2_B,
            node_color_range = c("blue", "gray", "red"),
            node_color_interval = c(-max(abs(R1_B-R2_B)), max(abs(R1_B-R2_B))),
            node_color_axis_label = "Standardized abudance \n difference across site (R1_B-R2_B)",
            node_size_axis_label = "OTU abudance sum per taxon\n (standard hellinger)",
            layout = "davidson-harel", initial_layout = "reingold-tilford")

```
  

Here we see that in the phylum *Protobacteia* the class *Gammaprotobacteria* is mostly detected by R1 and  *Alphaprotobacteria* is mostly detected by R1.
*Fimicutes* and *Actinobacteria* are better detected by R1

#### Better version with statistical significance based on rank
```{r}
max(obj1$data$diff_table$log2_median_ratio)

obj1%>%
  metacoder::filter_taxa(taxon_ranks == "o", supertaxa = TRUE)%>%
  metacoder::heat_tree(node_label = taxon_names,
          node_size = n_obs, # number of OTUs
          node_color = log2_median_ratio, # difference between groups
          node_color_interval = c(-10, 10), # symmetric interval
          node_color_range = c("cyan", "gray", "magenta"), # diverging colors
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Log 2 ratio of median counts",
          layout = "davidson-harel", initial_layout = "reingold-tilford",
          title = paste(unique(treatment_1) ,"vs", unique(treatment_2)))

obj1 %>%
  metacoder::mutate_obs("cleaned_names", gsub(taxon_names, pattern = "\\[|\\]", replacement = "")) %>%
  metacoder::filter_taxa(grepl(cleaned_names, pattern = "^[a-zA-Z]+$")) %>%
  metacoder::heat_tree(node_label = cleaned_names,
            node_size = n_obs, # number of OTUs
            node_color = log2_median_ratio, # difference between groups
            node_color_interval = c(-10, 10), # symmetric interval
            node_color_range = c("cyan", "gray", "magenta"), # diverging colors
            node_size_axis_label = "OTU count",
            node_color_axis_label = "Log 2 ratio of median counts",
            layout = "da", initial_layout = "re", # good layout for large trees
            title = paste(unique(treatment_1) ,"vs", unique(treatment_2)))

obj1%>%
  metacoder::filter_taxa(taxon_ranks == "o", supertaxa = TRUE)%>%
  metacoder::heat_tree(node_label = taxon_names,
          node_size = n_obs, # number of OTUs
          node_color = median_diff, # difference between groups
          node_color_interval = c(-max(abs(median_diff)), max(abs(median_diff))), # symmetric interval
          node_color_range = c("cyan", "gray", "magenta"), # diverging colors
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Median diff",
          layout = "davidson-harel", initial_layout = "reingold-tilford",
          title = paste(unique(treatment_1) ,"vs", unique(treatment_2)))

```

#### Differential expression of replicated count data

```{r}

obj1%>%
  metacoder::filter_taxa(taxon_ranks == "o", supertaxa = TRUE)%>%
  metacoder::heat_tree(node_label = taxon_names,
          node_size = n_obs, # number of OTUs
          node_color = logFC, # difference between groups
          node_color_interval = c(-max(abs(logFC)), max(abs(logFC))), # symmetric interval
          node_color_range = c("cyan", "gray", "magenta"), # diverging colors
          node_size_axis_label = "OTU count",
          node_color_axis_label = "logFC",
          layout = "davidson-harel", initial_layout = "reingold-tilford",
          title = paste(unique(treatment_1) ,"vs", unique(treatment_2)))
```

### Metagenomic R1 vs R2 

```{r}
meta_g_b_decond_table%>%
  make.tax.tree.comp(pair = c("R1_G","R2_G")) -> obj2
obj2%>%
  metacoder::filter_taxa(taxon_ranks == "o", supertaxa = TRUE)%>%
  metacoder::heat_tree(node_label = gsub(pattern = "\\[|\\]", replacement = "", taxon_names),
            node_size = R1_G+R2_G,
            node_color = R1_G-R2_G,
            node_color_range = c("blue", "gray", "red"),
            node_color_interval = c(-max(abs(R1_G-R2_G)), max(abs(R1_G-R2_G))),
            node_color_axis_label = "Standardized abudance \n difference across site (R1_G-R2_G)",
            node_size_axis_label = "OTU abudance sum per taxon\n (standard hellinger)",
            layout = "davidson-harel", initial_layout = "reingold-tilford")

```

Different pattern for metaG than metaB here in phylum *Protobacteia* the class *Gammaprotobacteria* and *Alphaprotobacteria* are both more detected by R1.
*Fimicutes* and *Actinobacteria* are also better detected by R1

#### Better version with statistical significance
```{r}

obj2%>%
  metacoder::filter_taxa(taxon_ranks == "o", supertaxa = TRUE)%>%
  metacoder::heat_tree(node_label = taxon_names,
          node_size = n_obs, # number of OTUs
          node_color = log2_median_ratio, # difference between groups
          node_color_interval = c(-10, 10), # symmetric interval
          node_color_range = c("cyan", "gray", "magenta"), # diverging colors
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Log 2 ratio of median counts",
          layout = "davidson-harel", initial_layout = "reingold-tilford",
          title = paste(unique(treatment_1) ,"vs", unique(treatment_2)))

obj2 %>%
  metacoder::mutate_obs("cleaned_names", gsub(taxon_names, pattern = "\\[|\\]", replacement = "")) %>%
  metacoder::filter_taxa(grepl(cleaned_names, pattern = "^[a-zA-Z]+$")) %>%
  metacoder::heat_tree(node_label = cleaned_names,
            node_size = n_obs, # number of OTUs
            node_color = log2_median_ratio, # difference between groups
            node_color_interval = c(-10, 10), # symmetric interval
            node_color_range = c("cyan", "gray", "magenta"), # diverging colors
            node_size_axis_label = "OTU count",
            node_color_axis_label = "Log 2 ratio of median counts",
            layout = "da", initial_layout = "re", # good layout for large trees
            title = paste(unique(treatment_1) ,"vs", unique(treatment_2)))

obj2%>%
  metacoder::filter_taxa(taxon_ranks == "o", supertaxa = TRUE)%>%
  metacoder::heat_tree(node_label = taxon_names,
          node_size = n_obs, # number of OTUs
          node_color = median_diff, # difference between groups
          node_color_interval = c(-max(abs(median_diff)), max(abs(median_diff))), # symmetric interval
          node_color_range = c("cyan", "gray", "magenta"), # diverging colors
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Log 2 ratio of median counts",
          layout = "davidson-harel", initial_layout = "reingold-tilford",
          title = paste(unique(treatment_1) ,"vs", unique(treatment_2)))

```

#### Differential expression of replicated count data

```{r}
obj2$data$
obj2%>%
  metacoder::filter_taxa(taxon_ranks == "o", supertaxa = TRUE)%>%
  metacoder::heat_tree(node_label = taxon_names,
          node_size = n_obs, # number of OTUs
          node_color = logFC, # difference between groups
          node_color_interval = c(-max(abs(logFC)), max(abs(logFC))), # symmetric interval
          node_color_range = c("cyan", "gray", "magenta"), # diverging colors
          node_size_axis_label = "OTU count",
          node_color_axis_label = "logFC",
          layout = "davidson-harel", initial_layout = "reingold-tilford",
          title = paste(unique(treatment_1) ,"vs", unique(treatment_2)))
```

### Metabarcoding R1 vs Metagenomic R1

```{r}
meta_g_b_decond_table%>%
  make.tax.tree.comp(pair = c("R1_B","R1_G")) -> obj3

obj3%>%
  metacoder::filter_taxa(taxon_ranks == "o", supertaxa = TRUE)%>%
  metacoder::heat_tree(node_label = gsub(pattern = "\\[|\\]", replacement = "", taxon_names),
            node_size = R1_B+R1_G,
            node_color = R1_B-R1_G,
            node_color_range = c("blue", "gray", "red"),
            node_color_interval = c(-max(abs(R1_B - R1_G)), max(abs(R1_B - R1_G))),
            node_color_axis_label = "Standardized abudance \n difference across site (R1_B-R1_G)",
            node_size_axis_label = "OTU abudance sum per taxon\n",
            layout = "davidson-harel", initial_layout = "reingold-tilford")

```

#### Better version with statistical significance
```{r}

obj3%>%
  metacoder::filter_taxa(taxon_ranks == "o", supertaxa = TRUE)%>%
  metacoder::heat_tree(node_label = taxon_names,
          node_size = n_obs, # number of OTUs
          node_color = log2_median_ratio, # difference between groups
          node_color_interval = c(-10,10), # symmetric interval
          node_color_range = c("cyan", "gray", "magenta"), # diverging colors
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Log 2 ratio of median counts",
          layout = "davidson-harel", initial_layout = "reingold-tilford",
          title = paste(unique(treatment_1) ,"vs", unique(treatment_2)))


obj3 %>%
  metacoder::mutate_obs("cleaned_names", gsub(taxon_names, pattern = "\\[|\\]", replacement = "")) %>%
  metacoder::filter_taxa(grepl(cleaned_names, pattern = "^[a-zA-Z]+$")) %>%
  metacoder::heat_tree(node_label = cleaned_names,
            node_size = n_obs, # number of OTUs
            node_color = log2_median_ratio, # difference between groups
            node_color_interval = c(-10, 10), # symmetric interval
            node_color_range = c("cyan", "gray", "magenta"), # diverging colors
            node_size_axis_label = "OTU count",
            node_color_axis_label = "Log 2 ratio of median counts",
            layout = "da", initial_layout = "re", # good layout for large trees
            title = paste(unique(treatment_1) ,"vs", unique(treatment_2)))

obj3%>%
  metacoder::filter_taxa(taxon_ranks == "o", supertaxa = TRUE)%>%
  metacoder::heat_tree(node_label = taxon_names,
          node_size = n_obs, # number of OTUs
          node_color = median_diff, # difference between groups
          node_color_interval = c(-max(abs(median_diff)), max(abs(median_diff))), # symmetric interval
          node_color_range = c("cyan", "gray", "magenta"), # diverging colors
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Log 2 ratio of median counts",
          layout = "davidson-harel", initial_layout = "reingold-tilford",
          title = paste(unique(treatment_1) ,"vs", unique(treatment_2)))
```

#### Differential expression of replicated count data

```{r}

obj3%>%
  metacoder::filter_taxa(taxon_ranks == "o", supertaxa = TRUE)%>%
  metacoder::heat_tree(node_label = taxon_names,
          node_size = n_obs, # number of OTUs
          node_color = logFC, # difference between groups
          node_color_interval = c(-max(abs(logFC)), max(abs(logFC))), # symmetric interval
          node_color_range = c("cyan", "gray", "magenta"), # diverging colors
          node_size_axis_label = "OTU count",
          node_color_axis_label = "logFC",
          layout = "davidson-harel", initial_layout = "reingold-tilford",
          title = paste(unique(treatment_1) ,"vs", unique(treatment_2)))
```


### Metabarcoding R2 vs Metagenomic R2

```{r}
meta_g_b_decond_table%>%
  make.tax.tree.comp(pair = c("R2_B","R2_G")) -> obj4

obj4%>%
  metacoder::filter_taxa(taxon_ranks == "o", supertaxa = TRUE)%>%
  metacoder::heat_tree(node_label = gsub(pattern = "\\[|\\]", replacement = "", taxon_names),
            node_size = R2_B+R2_G,
            node_color = R2_B-R2_G,
            node_color_range = c("blue", "gray", "red"),
            node_color_interval = c(-max(abs(R2_B-R2_G)), max(abs(R2_B-R2_G))),
            node_color_axis_label = "Standardized abudance \n difference across site (R2_B-R2_G)",
            node_size_axis_label = "OTU abudance sum per taxon\n",
            layout = "davidson-harel", initial_layout = "reingold-tilford")

```
#### Better version with statistical significance
```{r}

obj4%>%
  metacoder::filter_taxa(taxon_ranks == "o", supertaxa = TRUE)%>%
  metacoder::heat_tree(node_label = taxon_names,
          node_size = n_obs, # number of OTUs
          node_color = log2_median_ratio, # difference between groups
          node_color_interval = c(-10, 10), # symmetric interval
          node_color_range = c("cyan", "gray", "magenta"), # diverging colors
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Log 2 ratio of median counts",
          layout = "davidson-harel", initial_layout = "reingold-tilford",
          title = paste(unique(treatment_1) ,"vs", unique(treatment_2)))


obj4 %>%
  metacoder::mutate_obs("cleaned_names", gsub(taxon_names, pattern = "\\[|\\]", replacement = "")) %>%
  metacoder::filter_taxa(grepl(cleaned_names, pattern = "^[a-zA-Z]+$")) %>%
  metacoder::heat_tree(node_label = cleaned_names,
            node_size = n_obs, # number of OTUs
            node_color = log2_median_ratio, # difference between groups
            node_color_interval = c(-10, 10), # symmetric interval
            node_color_range = c("cyan", "gray", "magenta"), # diverging colors
            node_size_axis_label = "OTU count",
            node_color_axis_label = "Log 2 ratio of median counts",
            layout = "da", initial_layout = "re", # good layout for large trees
            title = paste(unique(treatment_1) ,"vs", unique(treatment_2)))

obj4%>%
  metacoder::filter_taxa(taxon_ranks == "o", supertaxa = TRUE)%>%
  metacoder::heat_tree(node_label = taxon_names,
          node_size = n_obs, # number of OTUs
          node_color = median_diff, # difference between groups
          node_color_interval = c(-max(abs(median_diff)), max(abs(median_diff))), # symmetric interval
          node_color_range = c("cyan", "gray", "magenta"), # diverging colors
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Log 2 ratio of median counts",
          layout = "davidson-harel", initial_layout = "reingold-tilford",
          title = paste(unique(treatment_1) ,"vs", unique(treatment_2)))
```

#### Differential expression of replicated count data

```{r}
obj4$data$diff_analysis_table
obj4%>%
  metacoder::filter_taxa(taxon_ranks == "o", supertaxa = TRUE)%>%
  metacoder::heat_tree(node_label = taxon_names,
          node_size = n_obs, # number of OTUs
          node_color = logFC, # difference between groups
          node_color_interval = c(-max(abs(logFC)), max(abs(logFC))), # symmetric interval
          node_color_range = c("cyan", "gray", "magenta"), # diverging colors
          node_size_axis_label = "OTU count",
          node_color_axis_label = "logFC",
          layout = "davidson-harel", initial_layout = "reingold-tilford",
          title = paste(unique(treatment_1) ,"vs", unique(treatment_2)))
```

Zero inflantion might bias the variance of taxa abudance in each method thus scaling factors are maybeunderestimated 

## differencial expression analysis
## Phyloseq



Test with unbalanced library size inside one ech (analogue to bias caused by one ech for exemple)
```{r}
data.frame(A =  c(10,     10,    20,    20),
           B =  c(10,     10,    20,    20),
           C =  c(10,     20,    10,    20),
           D =  c(100,    200,   50,    50),
           sp = c("sp1", "sp2", "sp3", "sp4"))%>%
  column_to_rownames("sp")-> otu_tab_test
```
The model should correct effect size, so with those data I expect:
 - no difference of expression for species 1 between method M1 and M1 (M1 = A, B ; M2 =C, D)
 - difference of around 2 or 3 fold change(FC) of sp2
 - difference of around 0.5 fold change of sp3
 - difference of  around 0.5 fold change for species 4 but NS.
 (FC = M2/M1)

```{r}
data.frame(taxon_id = c("sp1", "sp2", "sp3", "sp4"),
         family = c("f1", "f2", "f3" ,"f4"), 
         genus = c("g1", "g2", "g3", "g4")) %>%
  column_to_rownames("taxon_id") %>%
  as.matrix-> tax_tab_test

data.frame(sample_ID = colnames(otu_tab_test)) %>%
  mutate(method =c("M1", "M1", "M2", "M2")) %>%
  column_to_rownames("sample_ID") -> sampledata_test

physeq_obj_test = phyloseq(otu_table(otu_tab_test, taxa_are_rows = T), tax_table(tax_tab_test), sample_data(sampledata_test))

dge_test = phyloseq_to_edgeR(physeq_obj_test, group="method")
et_test = exactTest(dge_test, pair=c("M1", "M2"))
# Extract values from test results
tt_test = topTags(et_test, n=nrow(dge_test$table), adjust.method="fdr", sort.by="PValue")
res_test = tt_test@.Data[[1]]
alpha = 0.05
sigtab_test = res_test[(res_test$FDR < alpha), ]
sigtab_test = cbind(as(sigtab_test, "data.frame"), as(tax_table(physeq_obj_test)[rownames(sigtab_test), ], "matrix"))
res_test$FC = 2^res_test$logFC

knitr::kable(res_test)
```


```{r}

theme_set(theme_bw())
scale_fill_discrete <- function(palname = "Set1", ...) {
    scale_fill_brewer(palette = palname, ...)
}
sigtabgen_test = subset(sigtab_test, !is.na(genus))
# Phylum order
x = tapply(sigtabgen_test$logFC, sigtabgen_test$family, function(x) max(x))
x = sort(x, TRUE)
sigtabgen_test$family = factor(as.character(sigtabgen_test$family), levels = names(x))
# Genus order
x = tapply(sigtabgen_test$logFC, sigtabgen_test$genus, function(x) max(x))
x = sort(x, TRUE)
sigtabgen$Genus = factor(as.character(sigtabgen_test$genus), levels = names(x))
ggplot(sigtabgen_test, aes(x = genus, y = logFC, color = family)) + geom_point(size=6) + 
  theme(axis.text.x = element_text(angle = -90, hjust = 0, vjust = 0.5))
```

It seems that the model is able to correct the biais inside one sample and detect species that are differently distibued between the 2 methods

Test with unbalanced library size inside one method
```{r}
data.frame(A =  c(10,     10,    20,    20),
           B =  c(10,     10,    20,    20),
           C =  c(100,    200,   100,   200),
           D =  c(100,    200,   50,    50),
           sp = c("sp1", "sp2", "sp3", "sp4"))%>%
  column_to_rownames("sp")-> otu_tab_test2
```
The model should correct effect size, so with those data I expect:
 - no difference of expression for species 1 between method M1 and M1 (M1 = A, B ; M2 =C, D)
 - difference of around 2 or 3 fold change(FC) of sp2
 - difference of around 0.5 fold change of sp3
 - difference of  around 0.5 fold change for species 4 but NS.
 (FC = M2/M1)
 
```{r}
physeq_obj_test2 = phyloseq(otu_table(otu_tab_test2, taxa_are_rows = T), tax_table(tax_tab_test), sample_data(sampledata_test))

dge_test2 = phyloseq_to_edgeR(physeq_obj_test2, group="method")
et_test2 = exactTest(dge_test2, pair=c("M1", "M2"))
# Extract values from test results
tt_test2 = topTags(et_test2, n=nrow(dge_test2$table), adjust.method="fdr", sort.by="PValue")
res_test2 = tt_test2@.Data[[1]]
alpha = 0.05
sigtab_test2 = res_test2[(res_test2$FDR < alpha), ]
sigtab_test2 = cbind(as(sigtab_test2, "data.frame"), as(tax_table(physeq_obj_test2)[rownames(sigtab_test2), ], "matrix"))
res_test2$FC = 2^res_test2$logFC
knitr::kable(res_test2)
knitr::kable(res_test)
```

For this data set the model is able to correct the biais cause by one method and detect species that are differently distributed between the 2 methods.
For both data set we conclude the same thing, which is good. 




```{r}
make.tax.tree.comp = function(df,method){
  df %>%
  select(OTU, kingdom, phylum, class, order, family, genus, species, taxonomy, ends_with(method[1]), ends_with(method[2]))%>%
  mutate(sum_col = rowSums(across(c(ends_with(method[1]), ends_with(method[2]))),na.rm = T))%>%
  filter(sum_col != 0)%>%
  ## standardization of the table produce by the "method 1" (first method put in the vector)
  # mutate(across(ends_with(method[1]), ~ sqrt(. / rowSums(across(ends_with(method[1])))), .names = "hellinger_{col}"), 
  ## standardization of the table produce by the "method 2" (second method put in the vector)    
  #across(ends_with(method[2]), ~ sqrt(. / rowSums(across(ends_with(method[2])))), .names = "hellinger_{col}"),.keep = "unused")%>%
  # remove species that don't appear in the 2 method that we compare in this chunk}}
  mutate(total = rowSums(across(starts_with("BU")), na.rm = T))%>%
  filter(total !=0 )%>%
  # create metacoder object
  metacoder::parse_tax_data(class_cols = "taxonomy", # The column in the input table
                      class_sep = "; ",
                      class_regex = "^([a-z]{0,1})_{0,2}(.*)$",
                      class_key = c("tax_rank" = "taxon_rank", "name" = "taxon_name")) -> obj
  obj$data$tax_data
  # compute abudance (standadize by hellinger) per taxon for the 2 methode
  obj$data$tax_abund <- metacoder::calc_taxon_abund(obj, "tax_data",
                                       cols = startsWith(colnames(obj$data$tax_data),"BU"))
  
  obj$data$tax_abund_group <- metacoder::calc_taxon_abund(obj, "tax_data",
                                       cols = startsWith(colnames(obj$data$tax_data),"BU"),
                                                         groups = str_extract(str_subset(colnames(obj$data$tax_data), "_R\\d_[A-Z+]"), "R\\d_[A-Z+]"))
  obj$data$diff_table = metacoder::compare_groups(obj, "tax_abund",
                                       cols = startsWith(colnames(obj$data$tax_abund),"BU"),
                                                         groups = str_extract(str_subset(colnames(obj$data$tax_abund), "_R\\d_[A-Z+]"), "R\\d_[A-Z+]"))
  obj = mutate_obs(obj, "diff_table",
                  wilcox_p_value = p.adjust(wilcox_p_value, method = "fdr"))
  # Ns. set to 0
  obj$data$diff_table%>%
    mutate(median_diff = case_when(wilcox_p_value > 0.05 ~ 0,
                      .default  = median_diff),
           log2_median_ratio = case_when(wilcox_p_value > 0.05 ~ 0,
                      .default  = median_diff)) -> obj$data$diff_table

  return(obj)
}
```


```{r}
  # differential analysis of sequence read count data with edgeR
  #obj$data$tax_data %>%
  #  group_by(family)%>%
  #  summarise()
meta_g_b_decond_table_rare%>%
  make.tax.tree.comp(method = c("R1_B","R2_B")) -> obj1

obj1$data$tax_data %>%
  select(starts_with("BU"),taxon_id) %>%
  column_to_rownames("taxon_id") -> otu_tab
names(obj1$taxa)
# Get rank(taxa) of each id

tab %>%
    select(taxa) %>%
    pivot_longer(starts_with("BU"), names_to = "sample_id", values_to = "reads") %>%
    group_by(sample_id, {{taxa}},taxon_id) %>%
    summarise(reads_sum = sum(reads))%>%
    pivot_wider(names_from = "sample_id", values_from = "reads_sum", values_fill = 0) 
    

tax_abund%>%
  filter(taxon_rank == "k")
differential.analysis(obj1)



obj1$data$
obj1$data$tax_data %>%
  select(taxon_id , kingdom, phylum, class, order, family, genus) %>%
  column_to_rownames("taxon_id") %>%
  as.matrix-> tax_tab

data.frame(sample_ID = colnames(otu_tab)) %>%
  mutate(method = str_extract(sample_ID, "R\\d_[A-Z+]$")) %>%
  column_to_rownames("sample_ID") -> sampledata

physeq_obj = phyloseq(otu_table(otu_tab, taxa_are_rows = T), tax_table(tax_tab), sample_data(sampledata))

ge = phyloseq_to_edgeR(physeq_obj, group="method")
et = exactTest(ge, pair=c("R1_B", "R2_B"))
# Extract values from test results
tt = topTags(et, n=nrow(dge$table), adjust.method="fdr", sort.by="PValue")
res = tt@.Data[[1]]

pair_wise_taxa_df = res%>%select(logFC, logCPM, PValue, FDR)
taxa = "order"

obj1$data$tax_data%>%
  compute.diff.analysis.for.taxa(taxa = order)

obj1$data$tax_data %>%
    select(starts_with("BU"),taxon_id) %>%
    column_to_rownames("taxon_id") -> otu_tab

  for(taxa in c( "kingdom", "phylum", "class", "order", "family")){

}  
  
  obj1$data$tax_data %>%
    select(taxon_id , kingdom, phylum, class, order, family, genus) %>%
    column_to_rownames("taxon_id") %>%
    as.matrix-> tax_tab
  
  data.frame(sample_ID = colnames(otu_tab)) %>%
    mutate(method = str_extract(sample_ID, "R\\d_[A-Z+]$")) %>%
    column_to_rownames("sample_ID") -> sampledata
  
  physeq_obj = phyloseq(otu_table(otu_tab, taxa_are_rows = T), tax_table(tax_tab), sample_data(sampledata))
  
  ge = phyloseq_to_edgeR(physeq_obj, group="method")
  et = exactTest(ge, pair=c("R1_B", "R2_B"))
  # Extract values from test results
  tt = topTags(et, n=nrow(dge$table), adjust.method="fdr", sort.by="PValue")
  res = tt@.Data[[1]]
  
  pair_wise_taxa_df = cbind(pair_wise_taxa_df, res$FDR)
}
sigtab = res[(res$FDR < alpha), ]
sigtab = cbind(as(sigtab, "data.frame"), as(tax_table(physeq_obj)[rownames(sigtab), ], "matrix"))
   
theme_set(theme_bw())
scale_fill_discrete <- function(palname = "Set1", ...) {
    scale_fill_brewer(palette = palname, ...)
}
sigtabgen = subset(sigtab, !is.na(genus))
# Phylum order
x = tapply(sigtabgen$logFC, sigtabgen$phylum, function(x) max(x))
x = sort(x, TRUE)
sigtabgen$phylum = factor(as.character(sigtabgen$phylum), levels = names(x))
# Genus order
x = tapply(sigtabgen$logFC, sigtabgen$genus, function(x) max(x))
x = sort(x, TRUE)
sigtabgen$Genus = factor(as.character(sigtabgen$genus), levels = names(x))
ggplot(sigtabgen, aes(x = genus, y = logFC, color = phylum)) + geom_point(size=6) + 
  theme(axis.text.x = element_text(angle = -90, hjust = 0, vjust = 0.5))

obj1$data$tax_data %>%
  pivot_longer(starts_with("BU"), names_to = "sample_id", values_to =  "reads")%>%
  mutate(method = str_extract(sample_id, "R\\d_[BG]"))%>%
  group_by(taxon_id,method)%>%

  summarise(sum_reads = sum(reads))%>%
  pivot_wider(names_from = method, values_from = sum_reads)%>%
  mutate(diff_read = R1_B - R2_B)%>%
  mutate(diff_is = case_when(taxon_id %in% rownames(sigtabgen) ~ "signif",
                   !(taxon_id %in% rownames(sigtabgen)) ~ "NS"))%>%
  ggplot()+
  geom_point(aes(taxon_id, diff_read))+
  facet_wrap(~diff_is)

```
FC is for fold change which is a ratio between 2 quantities. For exemple :
A = 10 and B = 30 -> the FC of B with respect to A  is B/A, in this case it is
60/30 = 2 ; it is defined as a fold-change of 3
30/60 = 0.5 ; it is defined as a fold-change of 2

(if the pair is c("A","B") then the comparison is B - A, so genes with positive 
log-fold change are up-regulated in group B compared
with group A (and vice versa for genes with negative log-fold change).)

### Ralative abudances

```{r}
meta_g_b_decond_table_rare%>%
  pivot_longer(starts_with("BU"), names_to = "ID", values_to = "abundance")%>%
  mutate(method = str_extract(ID, "R\\d+_[BG]"),
         soil_code = str_extract(ID, "^BU_[A-Z]+_\\d+"))%>%
  group_by(ID)%>%
  mutate(relative_abudance = abundance/sum(abundance))%>%
  ggplot()+
  facet_wrap(~soil_code)+
  geom_col(aes(method,relative_abudance  ,fill = order))+
  main_theme+
  theme(legend.position="none",
        axis.text.x =element_text(angle = 90,vjust = 1, hjust = 1, size = 6, face="italic"))

meta_g_b_decond_table_rare%>%
  pivot_longer(starts_with("BU"), names_to = "ID", values_to = "abundance")%>%
  mutate(method = str_extract(ID, "R\\d+_[BG]"),
         soil_code = str_extract(ID, "^BU_[A-Z]+_\\d+"))%>%
  group_by(ID)%>%
  mutate(relative_abudance = abundance/sum(abundance))%>%
  ungroup()%>%
  group_by(order, method)%>%
  summarise(relative_abudance_mean = mean(relative_abudance))%>%
  ggplot()+
  #facet_wrap(~order)+
  geom_raster(aes(method,order, fill = relative_abudance_mean))+
  main_theme+
  theme(legend.position="none",
        axis.text.x =element_text(angle = 90,vjust = 1, hjust = 1, size = 6, face="italic"))
  
```

